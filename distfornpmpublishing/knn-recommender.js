!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports["knn-recommender"]=t():e["knn-recommender"]=t()}(this,(function(){return(()=>{"use strict";var e={d:(t,r)=>{for(var i in r)e.o(r,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:r[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{default:()=>r});class r{constructor(e){this.rowToRowSimilarityMap={},this.rowIdToRowNumberMap={},this.columnIdToColumnNumberMap={},this.initialized=!1,e?(this.checkMatrix(e),this.matrix=e):(this.matrix=new Array(new Array),this.matrix[0].push("emptycorner"))}checkMatrix(e){if(!e||!e[0]||e[0].constructor!==Array||"string"!=typeof e[0][1])throw new TypeError("Malformatted matrix. It should be a non zero two dimensional array in the format [['emptycorner', 'item 1', 'item 2', 'item 3'], ['user 1', 1, -1, 0], ['user 2', 0, -1, 1]]")}initializeRecommender(){return new Promise(((e,t)=>{this.rowIdToRowNumberMap={},this.columnIdToColumnNumberMap={},this.calculateDistancesInZeroOneMatrixAndCreateRowIdToRowNumberAndColumnIdToColumnNumberMapsInChunks().then((t=>{this.initialized=!0,e(t)})).catch((e=>{t(e)}))}))}initializeRecommenderForUserId(e){this.initializeRecommenderForRowId(e)}initializeRecommenderForItemId(e){this.initializeRecommenderForRowId(e)}initializeRecommenderForRowId(e){this.rowIdToRowNumberMap[e]=0;for(let t=0;t<this.matrix.length;t++)if(this.matrix[t][0]===e)return this.calculateDistancesInZeroOneMatrixAndCreateRowIdToRowNumberAndColumnIdToColumnNumberMaps(t,t+1),void(this.initialized=!0);throw Error(`Id ${e} not found as a row in the matrix!`)}getNNearestNeighboursForUserId(e,t=-1){return this.getNNearestNeighboursForRowId(e,t)}getNNearestNeighboursForItemId(e,t=-1){return this.getNNearestNeighboursForRowId(e,t)}getNNearestNeighboursForRowId(e,t=-1){this.checkInitiated();let r=this.rowToRowSimilarityMap[e];if(!r)throw Error(`Similarities not initialized for rowId: ${e}`);return-1!==t&&r.length>t?r.slice(0,t):r}generateNNewRecommendationsForUserId(e,{amountOfDesiredNewRecommendations:t=1,amountOfDesiredNearestNeighboursToUse:r=3,excludingTheseItems:i=[]}={}){return this.checkInitiated(),this.generateNNewRecommendationsForUserIdInternal(e,{onlyUnique:!1,amountOfDesiredNewRecommendations:t,amountOfDesiredNearestNeighboursToUse:r,excludingTheseItems:i})}generateNNewUniqueRecommendationsForUserId(e,{amountOfDesiredNewRecommendations:t=1,amountOfDesiredNearestNeighboursToUse:r=3,excludingTheseItems:i=[]}={}){return this.checkInitiated(),this.generateNNewRecommendationsForUserIdInternal(e,{onlyUnique:!0,amountOfDesiredNewRecommendations:t,amountOfDesiredNearestNeighboursToUse:r,excludingTheseItems:i})}addLikeForUserToAnItem(e,t){this.updateMatrixForRowIdAndColumnId(e,t,1)}addDislikeForUserToAnItem(e,t){this.updateMatrixForRowIdAndColumnId(e,t,-1)}addCharacteristicForItem(e,t){this.updateMatrixForRowIdAndColumnId(e,t,1)}removeCharacteristicForItem(e,t){this.updateMatrixForRowIdAndColumnId(e,t,0)}updateMatrixForRowIdAndColumnId(e,t,r){if(!this.rowIdToRowNumberMap[e]||!this.columnIdToColumnNumberMap[t])throw new Error("userId or itemId not valid when updating user's value. Have you initialized the recommender after adding new items or users?");this.matrix[this.rowIdToRowNumberMap[e]][this.columnIdToColumnNumberMap[t]]=r}addNewUserToDataset(e){if(!e||e.length!=this.matrix[0].length)throw new Error("The row to be added doesn't have the same amount of columns as the other items in the matrix");if("string"!=typeof e[0])throw new Error("The row to be added isn't in the correct format that should be ['user id', 0, 1, ...]");if(this.rowIdToRowNumberMap[e[0]])throw new Error(`A row for the given id: ${e[0]} already exists in the user item matrix. Can't add a second row for the same user id. `);this.rowIdToRowNumberMap[e[0]]=this.matrix.push(e)-1}addNewEmptyUserToDataset(e){this.addNewEmptyRowToDataset(e)}addNewEmptyItemAsRowToDataset(e){this.addNewEmptyRowToDataset(e)}addNewEmptyRowToDataset(e){let t=new Array(this.matrix[0].length);t[0]=e;for(let e=1;e<this.matrix[0].length;e++)t[e]=0;this.addNewUserToDataset(t)}addNewItemToDataset(e){this.addNewColumnToDataset(e)}addNewItemCharacteristicToDataset(e){this.addNewColumnToDataset(e)}addNewColumnToDataset(e){this.columnIdToColumnNumberMap[e]=this.matrix[0].push(e)-1;for(let e=1;e<this.matrix.length;e++)this.matrix[e].push(0)}getAllRecommendationsForUserId(e){const t=this.rowIdToRowNumberMap[e];if(!t)throw new Error(`Invalid or non initialized user id ${e}`);return this.matrix[t]}generateNNewRecommendationsForUserIdInternal(e,{onlyUnique:t=!1,amountOfDesiredNewRecommendations:r=1,amountOfDesiredNearestNeighboursToUse:i=3,excludingTheseItems:o=[]}={}){const a=this.getAllRecommendationsForUserId(e),n=this.getNNearestNeighboursForUserId(e,i);let s=new Array(r),m=0,d={};for(let e=0;e<n.length;e++){const i=this.getAllRecommendationsForUserId(n[e].otherRowId);for(let h=1;h<a.length;h++)if(!(t&&d[h]||1!==i[h]||0!==a[h]||o.includes(this.matrix[0][h]))){if(s[m]={itemId:this.matrix[0][h],recommenderUserId:n[e].otherRowId,similarityWithRecommender:n[e].similarity},m++,m>=r)return s;d[h]=!0}}return s}checkInitiated(){if(!this.initialized)throw new Error("Recommender not initialized!")}calculateDistancesInZeroOneMatrixAndCreateRowIdToRowNumberAndColumnIdToColumnNumberMapsInChunks(){return new Promise(((e,t)=>{this.chunkIntermediator(1,this.matrix.length,e,t)}))}chunkIntermediator(e,t,r,i){const o=e+3>t?t:e+3;try{this.calculateDistancesInZeroOneMatrixAndCreateRowIdToRowNumberAndColumnIdToColumnNumberMaps(e,o)}catch(e){return void i(e)}o<t?setTimeout((()=>this.chunkIntermediator(e+3,t,r,i)),0):(this.initialized=!0,r(!0))}calculateDistancesInZeroOneMatrixAndCreateRowIdToRowNumberAndColumnIdToColumnNumberMaps(e,t){const r=this.matrix.length,i=this.matrix[0].length;let o=!1;for(let a=e;a<t;a++){let e=Array(r-2),t=0;for(let n=1;n<r;n++){if(a===n)continue;let r=0,s=0;for(let e=1;e<i;e++)o||(this.columnIdToColumnNumberMap[this.matrix[0][e]]=e),void 0!==this.matrix[a][e]&&0!==this.matrix[a][e]&&this.matrix[a][e]===this.matrix[n][e]?(r++,s++):void 0===this.matrix[a][e]||void 0===this.matrix[n][e]||0===this.matrix[a][e]&&0===this.matrix[n][e]||s++;o=!0;let m=0!==s?r/s:0;if("string"!=typeof this.matrix[n][0])throw new TypeError(`Malformatted matrix. Element atat index [${n}][0] is not a string (describing a user/item id). The invalid element is: ${this.matrix[n][0]}`);e[t]={otherRowId:this.matrix[n][0],similarity:m},t++}if("string"!=typeof this.matrix[a][0])throw new TypeError(`Malformatted matrix. Element atat index [${a}][0] is not a string (describing a user/item id). The invalid element is: ${this.matrix[a][0]}`);if(this.rowIdToRowNumberMap[this.matrix[a][0]])throw new Error(`Malformatted matrix. The matrix contains two rows with the same id: ${this.matrix[a][0]}`);this.rowIdToRowNumberMap[this.matrix[a][0]]=a,this.rowToRowSimilarityMap[this.matrix[a][0]]=this.sortRowToOtherRowsSimilarityListByRowToRowSimilarityDescending(e)}}sortRowToOtherRowsSimilarityListByRowToRowSimilarityDescending(e){return e.sort(((e,t)=>e.similarity>t.similarity?-1:1))}}return t})()}));